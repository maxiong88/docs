---
title: es56
date: 2016-09-29 22:12:25
tags:
---

了解：

    var z1 = 1;
	var z2 = '1';
	var z3 = 1;
	console.log(""+(z3 == z1)+"相同类型、相同值");//true
	console.log(""+(z3 === z1)+"相同类型、相同值");//true
	console.log(""+(z3 !== z1)+"相同类型、相同值,非运算符");//false
	console.log(""+(z1 == z2)+"把str转换为数字，检查其是否相等。");//true
	console.log(""+(z1 != z2)+"//false  == 的 非运算");//false
	console.log(""+(z1 === z2)+"不同类型");//false
	console.log(""+(z1 !== z2)+"不同类型非运算符 ");//true


	
`== 和 != 比较若类型不同，先偿试转换类型，再作值比较，最后返回值比较结果 。`

`=== 和 !== 只有在相同类型下,才会比较其值。`

<!-- more -->

#scmascript6 入门

npm init  创建package.json

安装babel,命令行工具,当前目录下

     $ npm install --save-dev babel-cli

使用方法

    # 转码结果输出到标准输出
	$ babel example.js
	
	# 转码结果写入一个文件
	# --out-file 或 -o 参数指定输出文件
	$ babel example.js --out-file compiled.js
	# 或者
	$ babel example.js -o compiled.js
	
	# 整个目录转码
	# --out-dir 或 -d 参数指定输出目录
	$ babel src --out-dir lib
	# 或者
	$ babel src -d lib
	
	# -s 参数生成source map文件
	$ babel src -d lib -s

配置文件.babelrc,需要那个安装哪个

	# ES2015转码规则
	$ npm install --save-dev babel-preset-es2015
	
	# react转码规则
	$ npm install --save-dev babel-preset-react
	
	# ES7不同阶段语法提案的转码规则（共有4个阶段），选装一个
	$ npm install --save-dev babel-preset-stage-0
	$ npm install --save-dev babel-preset-stage-1
	$ npm install --save-dev babel-preset-stage-2
	$ npm install --save-dev babel-preset-stage-3

然后，将这些规则加入.babelrc。

	{
	"presets": [
	  "es2015",
	  "react",
	  "stage-2"
	],
	"plugins": []
	}

# 1.let命令

let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。

```js
	{
	     var a1 = "a1";
		 let a2 = "a2"
	}
	console.log(a1);//a1
	console.log(a2);// a2 is not defined 
```

for循环

	for(let i=0;i<10;i++){
	    console.log(i)
	}
	for(var i1=0;i1<10;i1++){
	    console.log(i1)
	}
	console.log(i1);//10
	console.log(i);// i is not defined

不存在变量提升

let不像var那样会发生“变量提升”现象。所以，变量一定要在声明后使用，否则报错。

	console.log(foo); // 输出undefined
	console.log(bar); // 报错ReferenceError:can't access lexical declaration `bar' before initialization
	
	var foo = 2;
	let bar = 2;

不允许重复声明

let不允许在相同作用域内，重复声明同一个变量

	function x(){
	   let aa = "111";
	   let aa = "222";
	}
    //SyntaxError: redeclaration of let aa
	
	function x(){
	   var aa = "111";
	   let aa = "222";
	}
	//SyntaxError: redeclaration of var aa

# 2.块级作用域

ES5只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。

## 为什么需要块级作用域

第一种场景，内层变量可能会覆盖外层变量。

	var tmp = new Date();
	
	function f() {
	  console.log(tmp);
	  if (false) {
	    var tmp = "hello world";
	  }
	}
	
	f(); // undefined

上面代码中，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。

	var tmp = new Date();
	function f(){
	    console.log(tmp);
	}
	f();// Date {Mon Oct 10 2016 13:40:18 GMT+0800}

第二种场景，用来计数的循环变量泄露为全局变量。

	var s = 'hello';
	
	for (var i = 0; i < s.length; i++) {
	  console.log(s[i]);
	}
	
	console.log(i); // 5

上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。

## ES6的块级作用域

	function f1() {
	  let n = 5;
	  if (true) {
	    let n = 10;//内层作用域可以定义外层作用域的同名变量。
	  }
	  console.log(n); // 5
	}

上面的函数有两个代码块，都声明了变量n，运行后输出5。这表示外层代码块不受内层代码块的影响（`外层作用域无法读取内层作用域的变量。`）。如果使用var定义变量n，最后输出的值就是10。

	function f1() {
	  var n = 5;
	  if (true) {
	    var n = 10;
	  }
	  console.log(n); // 10
	}

块级作用域的出现，实际上使得获得广泛应用的立即执行匿名函数（IIFE）不再必要了。

	// IIFE写法
	(function () {
	  var tmp = ...;
	  ...
	}());
	
	// 块级作用域写法
	{
	  let tmp = ...;
	  ...
	}

## 块级作用域与函数声明

ES5规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。

前面那段代码，在Chrome环境下运行会报错。

	// ES6的浏览器环境
	function f() { console.log('I am outside!'); }
	(function () {
	  if (false) {
	    // 重复声明一次函数f
	    function f() { console.log('I am inside!'); }
	  }
	
	  f();
	}());
	// Uncaught TypeError: f is not a function

上面的代码报错，是因为实际运行的是下面的代码。

	// ES6的浏览器环境
	function f() { console.log('I am outside!'); }
	(function () {
	  var f = undefined;//函数提升
	  if (false) {
	    function f() { console.log('I am inside!'); }
	  }
	
	  f();
	}());
	// Uncaught TypeError: f is not a function

考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。

`感觉不对`
	
	// 函数声明语句
	{
	  let a = 'secret';
	  function f() {
	    return a;
	  }
	}
	
	// 函数表达式
	{
	  let a = 'secret';
	  let f = function () {
	    return a;
	  };
	}