---
title: eventLoop 事件循环机制
description: '翻译了一部分'
sidebar: 'auto'
time: '2020-01-01'
prev: ''
next: ''
---

事件循环的工作是不断监视消息队列（用于任务）和执行堆栈，并在堆栈为空时将第一个回调函数按行推送到执行堆栈上。

在消息队列中创建的所有任务都不相同。有宏观任务和微观任务。

宏任务的例子有setInterval、setImmediate、setTimeout、I/O任务。

微任务的例子有Promises、process.nextTick。

对于每个“事件循环”，宏任务队列中会完成一个宏任务。完成相应的宏任务后，事件循环访问微任务队列，并在转到下一个队列之前完成整个队列。


:::tip js 调用栈 (call stack)

调用栈是一种栈结构,它用来存储计算机程序执行时候其活跃子程序的信息。

调用栈其实就是一种解析器去处理程序的机制，它是栈数据结构。它能追踪子程序的运行状态。
（1）当脚本要调用一个函数时，解析器把该函数添加到栈中并且执行这个函数。并形成一个栈帧
（2）任何被这个函数调用的函数会进一步添加到调用栈中，形成另一个栈帧,并且运行到它们被上个程序调用的位置。
（3）当执行完这个函数后，如果它没有调用其他函数，则它会从调用栈中推出。然后调用栈继续运行其他部门。
（4) 异步函数的回调函数一般都会被添加到运行队列里面，如settimeout会在响应的时间后把回调函数放入队列中，队列里的函数需要等栈为空时才会被推入栈中执行。如果队列中有其他函数，需要等队列前面的函数被堆入调用栈中之后才会运行。
:::



# Event loops




## 为什么js是单线程

js是一种单线程编程语言。它一次只能做一件事。浏览器只分配给js一个主线程,用来执行任务

这样简化了您的编程方式，而无需担心并发问题。你只需要注意如何编写代码，并避免任何可能阻塞线程的事情。

h5的`web worker`允许js脚本创建多个线程，但子线程完全受主线程控制，且不得操作DOM。

幸运的是，浏览器为我们提供了js引擎本身不提供的一些功能：webapis。包括DOMAPI、settimeout、http请求。
它可以帮助我们创建一些异步的，非阻塞的行为。


chrome v8引擎运行时由stack和heap组成，heap用于分配内存、stack用于已进行函数调用

浏览器包含：一个`call stack`[调用栈、调用堆栈、函数调用栈]-》先入先出，一个`event loop`[事件循环]，一个`callback queue`[回调列队]，以及一些api和特性[APIS and stuff]

+ webAPI-诸如ajax、settimeout、events等调用，这些都不属于V8引擎，二是由浏览器提供对此支持
+ callBack queue 所有异步回调或事件都将推送到此队列
+ eventloop 在堆栈和队列中查找一个函数，如果堆栈为空，则将内容从回调队列推送到堆栈。

## 任务列队

单线程模型带来了一些问题，主要是新的任务被加在队列的尾部，只有前面的所有任务运行结束，才会轮到它执行。
如果有一个任务特别耗时，后面的任务都会停在那里等待，造成浏览器失去响应，又称“假死”

如果排队是因为计算量大，CPU忙不过来，倒也算了，但是很多时候CPU是闲着的，因为IO设备（输入输出设备）很慢（比如Ajax操作从网络读取数据），不得不等着结果出来，再往下执行。

JavaScript语言的设计者意识到，这时主线程完全可以不管IO设备，挂起处于等待中的任务，先运行排在后面的任务。等到IO设备返回了结果，再回过头，把挂起的任务继续执行下去。
这种机制就是JavaScript内部采用的Event Loop。

任务分为两种 一是同步任务，二是异步任务

+ 同步任务（synchronous）同步任务指的是，在主线程上排队执行的任务，只有前一个任务执行完毕，才能执行后一个任务
+ 异步任务（asynchronous）异步任务指的是，不进入主线程、而进入"任务队列"（task queue）的任务，只有"任务队列"通知主线程，某个异步任务可以执行了，该任务才会进入主线程执行


只要主线程空了，就会去读取"任务队列"，这就是JavaScript的运行机制。这个过程会不断重复。


### IO设备


## eventloop

在完成整个进程或线程之后，必须将信息返回到主线程；这就是事件循环的作用所在。

主线程从"任务队列"中读取事件，这个过程是循环不断的，所以整个的这种运行机制又称为Event Loop（事件循环）。

![Philip Roberts的演讲](../.vuepress/public/assets/img/bg2014100802.png)

只要栈中的代码执行完毕，主线程就会去读取"任务队列"，依次执行那些事件所对应的回调函数。

执行栈中的代码（同步任务），总是在读取"任务队列"（异步任务）之前执行

需要注意的是，setTimeout()只是将事件插入了"任务队列"，必须等到当前代码（执行栈）执行完，主线程才会去执行它指定的回调函数。

JS是单线程的，它创建了事件循环的概念来异步运行多个任务。事件循环执行消息队列和执行堆栈的持续监视功能。

当执行堆栈变空时，事件循环将执行堆栈上的第一个回调函数对齐。

一个连续检查调用堆栈是否为空的进程。如果调用堆栈为空，则检查是否有任何函数等待调用。如果是，那么消息队列表中的第一个函数将移动到调用堆栈中，并从调用堆栈中执行它。这整个过程称为“事件循环”。


## nodejs的eventloop

Node.js也是单线程的Event Loop，但是它的运行机制不同于浏览器环境。

V8引擎解析js脚本







理解事件循环如何运行对于代码优化是重要的，有时对于正确的架构也很重要。

事件循环有隐含事件循环、显示事件循环

宏任务列队是V8术语

队列里的任务执行基于“先进先出”原则。

::: tip  两个更细节的点：
当引擎处理任务时不会执行渲染。如果执行需要很长一段时间也是如此。对于 DOM 的修改只有当任务执行完成才会被绘制。
如果一个任务执行时间过长，浏览器无法处理其他任务，在一定时间后就会在整个页面抛出一个如“页面未响应”的警示建议终止这个任务。这样的场景经常发生在很多复杂计算或者程序错误执行到死循环里。
:::


在每个宏任务之后，引擎立即执行所有微任务队列中的任务，比任何其他的宏任务或者渲染或者其他事情都要优先。

所有的微任务在任何其他的事件处理或者渲染或者任何其他的宏任务发生之前完成调用。


``` js
console.log("first");
setTimeout(function() {
    console.log("second")
}, 0);
console.log("third");
console.trace();

first
third
console.trace()
second
```

什么？即使我们将setTimeout设置为0秒，它仍然在最后执行。

所以，Javascript的异步特性来了。SetTimeOut不属于运行时环境，是浏览器提供的Web Api的一部分。
`stack`按顺序获取所有内容，但setTimeOut进入webapi，计时器运行0秒后，而不是将其放回堆栈，而是将其放回回调队列`callback queue`，然后堆栈继续执行下一个调用。
一旦堆栈变空，事件循环`eventloop`就会出现，并获取回调队列中的第一个元素并将其传递给堆栈，从而执行它。

使用setTimeout时，JavaScript将在将回调添加到队列之前等待延迟毫秒。那时，如果队列中仍然有以前的消息，那么将首先处理这些消息，并且我们的回调可能会在延迟毫秒之后被调用。因此，延迟不是保证的确切延迟，而是最小延迟。

这就是为什么在一个零延迟的函数上设置setTimeout仍然可以确保在当前消息完成之后（实际上，在它之前的队列中的所有其他消息之后）调用该函数。

注意-setTimeout不保证在给定时间内执行，而是保证执行的最短时间。

所有web Api的工作方式都是一样的。浏览器通过调用XHR来解析任何ajax调用，并将回调传递给队列，但是程序继续执行，一旦堆栈清除，函数就传递给堆栈并继续执行。





事件循环 运行一个`while`循环 同步等待消息，同步处理消息，然后重复执行

``` js
while (queue.waitForMessage()) {
  queue.processMessage();
}
```